import { __assign } from 'tslib';
import { Observable } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var fetch = (/**
 * @param {?} req
 * @param {?} httpClient
 * @return {?}
 */
function (req, httpClient) {
    /** @type {?} */
    var shouldUseBody = ['POST', 'PUT', 'PATCH'].indexOf(req.method.toUpperCase()) !== -1;
    /** @type {?} */
    var shouldStringify = (/**
     * @param {?} param
     * @return {?}
     */
    function (param) {
        return ['variables', 'extensions'].indexOf(param.toLowerCase()) !== -1;
    });
    // `body` for some, `params` for others
    /** @type {?} */
    var bodyOrParams = {};
    if (((/** @type {?} */ (req.body))).length) {
        if (!shouldUseBody) {
            return new Observable((/**
             * @param {?} observer
             * @return {?}
             */
            function (observer) {
                return observer.error(new Error('Batching is not available for GET requests'));
            }));
        }
        bodyOrParams = {
            body: req.body,
        };
    }
    else {
        if (shouldUseBody) {
            bodyOrParams = {
                body: req.body,
            };
        }
        else {
            /** @type {?} */
            var params = Object.keys(req.body).reduce((/**
             * @param {?} obj
             * @param {?} param
             * @return {?}
             */
            function (obj, param) {
                /** @type {?} */
                var value = ((/** @type {?} */ (req.body)))[param];
                obj[param] = shouldStringify(param) ? JSON.stringify(value) : value;
                return obj;
            }), {});
            bodyOrParams = { params: params };
        }
    }
    // create a request
    return httpClient.request(req.method, req.url, __assign({ observe: 'response', responseType: 'json', reportProgress: false }, bodyOrParams, req.options));
});
/** @type {?} */
var mergeHeaders = (/**
 * @param {?} source
 * @param {?} destination
 * @return {?}
 */
function (source, destination) {
    if (source && destination) {
        /** @type {?} */
        var merged = destination
            .keys()
            .reduce((/**
         * @param {?} headers
         * @param {?} name
         * @return {?}
         */
        function (headers, name) { return headers.set(name, destination.getAll(name)); }), source);
        return merged;
    }
    return destination || source;
});
/**
 * @template T
 * @param {...?} values
 * @return {?}
 */
function prioritize() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    /** @type {?} */
    var picked = values.find((/**
     * @param {?} val
     * @return {?}
     */
    function (val) { return typeof val !== 'undefined'; }));
    if (typeof picked === 'undefined') {
        return values[values.length - 1];
    }
    return picked;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { prioritize, fetch, mergeHeaders };

//# sourceMappingURL=ng.apolloLink.httpCommon.js.map